#!/bin/sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh gradlew ...
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * POSIX-style arithmetic «$((...))»;
#         * ASCII-compliant collating sequence;
#         * «export» variables that are currently in the environment;
#         * «test -L» (symlink detection).
#
#   (2) It turns out that shells which are lacking one or more of these features
#       (usually some of the expansions) are strictly ISO-9899 compliant.
#       Therefore, this script assumes a POSIX-compliant shell is available.
#
#       Also, to be safe, this script does not assume that any particular
#       utility is available, such as «basename» or «dirname» or «realpath» or
#       «readlink» or «sed» or «tr» or «which» or «xargs».
#
##############################################################################

# This is just a script.  It does not use the shell's current environment.
# (But it does modify its own environment as it runs.)

# This script is intended to be run by any POSIX-compliant shell.
# It should not be sourced.
if [ "$0" != "${0%/*}" ] ; then
    # The script was run with a path, e.g. ./gradlew
    # This is the standard way to run it.
    echo "ERROR: This script must be run as an executable."
    echo "       Do not source it."
    exit 1
fi

# Resolve the location of the gradle wrapper jar
#
# The wrapper jar is located relative to this script.
#
# We do not use `dirname $0` because it is not robust enough.
# Instead, we use a shell function to resolve the location.
#
# The function `resolve_location` takes one argument: the path to this script.
# It returns the absolute path to the directory containing this script.
#
# The function uses `cd` to change directories, but it does so in a subshell
# so that the current working directory is not changed.
resolve_location() {
    (
        cd "${1%/*}"
        pwd -P
    )
}

# The location of the gradle wrapper jar
#
# We use the `resolve_location` function to find the directory containing this script.
# Then we append the relative path to the wrapper jar.
WRAPPER_JAR="$(resolve_location "$0")/gradle/wrapper/gradle-wrapper.jar"

# Check if the wrapper jar exists
if [ ! -f "$WRAPPER_JAR" ] ; then
    echo "ERROR: The gradle wrapper jar was not found."
    echo "       It should be located at: $WRAPPER_JAR"
    exit 1
fi

# The java command to use
#
# We use the JAVA_HOME environment variable if it is set.
# Otherwise, we use `java`.
if [ -n "$JAVA_HOME" ] ; then
    JAVA_CMD="$JAVA_HOME/bin/java"
else
    JAVA_CMD="java"
fi

# The arguments to pass to the gradle wrapper
#
# We pass all arguments passed to this script to the gradle wrapper.
ARGS="$@"

# Run the gradle wrapper
exec "$JAVA_CMD" "-jar" "$WRAPPER_JAR" $ARGS
